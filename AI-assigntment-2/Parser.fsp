// Open the file that defines the type "expr" we shall use as AST
%{
open TypesAST
%}

// Declare the tokens (terminal symbols)
%token <string> VAR
%token <float> NUM
%token NOT BIIMPLICATION IMPLICATION COMMA TRUE FALSE AND OR EQUAL LPAR RPAR LCUR RCUR EOF
// NOTE: the actual formats of these tokens are defined in the lexer file
//       as regular expressions

// Specify precedence and associativity of operators
// Precedence is given by the order (from low to high)
%left COMMA
%left TRUE FALSE LCUR RCUR
// Comparison expressions
%left EQUAL
%left LBRA RBRA 
// Fra diskret: () binder stærkere en ¬ binder stærkere end ∧, ∨ binder stærkere end →, ↔ .
%left IMPLICATION BIIMPLICATION
%left AND OR
%left NOT
%left LPAR RPAR

// We declare the initial non-terminal symbol
%start cExpression

// We specify the return type of each of then non-terminal symbols
%type <a> aExpression
%type <Predicate> bExpression
%type <C> cExpression
%type <D> dExpression

// Grammar productions
%%

// Note that we need to insert an End-Of-File (EOF)
// The code annotation { $1 } specifies that parsing with this production
// returns whatever parsing the expression returns: $1 is the result of parsing
// the first component of the production (i.e. expression)

// The productions for expressions are like in the grammar we saw in class
// written in the yacc format:

dExpression:
  | aExpression { Belief($1) }
  | dExpression COMMA dExpression { BelievesSetSequence($1,$3) }
cExpression:
  | LCUR array_values RCUR {BelievesSet($2)}
  | cExpression COMMA cExpression { InitialValues($1,$3) }
aExpression:
  | NUM                               { Num($1) }
  | VAR                               { True($1) } 
  | NOT aExpression                   {Not($2)}
  | aExpression AND aExpression       { And($1,$3) }
  | aExpression OR aExpression        { Or($1,$3) }
  | LPAR aExpression RPAR             { $2 }
  | aExpression IMPLICATION aExpression {Implication($1,$3)}
  | aExpression BIIMPLICATION aExpression {BiImplication($1,$3)}
bExpression:
  | FALSE                             { False }
  | aExpression EQUAL aExpression     { Equal($1,$3) }
  | LPAR bExpression RPAR             { $2 }

array_values:
  | { [] }
  | rev_values { List.rev $1 }

rev_values:
  | aExpression { [$1] }
  | rev_values COMMA aExpression { $3 :: $1 }
// Again, the code annotation specifies the result of parsing
// For example { TimesExpr($1,$3) } specifies that parsing with the production
// returns the value TimesExpr($1,$3), where $i is the result of parsing
// component i in the production (in this case the lhs and rhs operands)

%%
