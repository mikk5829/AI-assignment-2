// Open the file that defines the type "expr" we shall use as AST
%{
open TypesAST
%}

// Declare the tokens (terminal symbols)
%token <string> VAR
%token <float> NUM
%token NOT BIIMPLICATION IMPLICATION COMMA MULTIPLY DIVIDE ADDITION SUBTRACT ZERO POWER TRUE FALSE AND OR EQUAL NEGEQUAL LT LTE GT GTE LPAR RPAR LCUR RCUR LBRA RBRA ASSIGN ASSIGNARRAY SEQUENCE SKIP IF FI DO OD CONDITION ELSE EOF
// NOTE: the actual formats of these tokens are defined in the lexer file
//       as regular expressions

// Specify precedence and associativity of operators
// Precedence is given by the order (from low to high)
%left COMMA
%left TRUE FALSE LCUR RCUR ASSIGN SKIP IF FI DO OD CONDITION
// Comparison expressions
%left LT LTE GT GTE EQUAL NEGEQUAL
// Conditional expressions
%right ELSE SEQUENCE
// Arithmetic expressions
%left ADDITION 
%left MULTIPLY DIVIDE
%right POWER
%left SUBTRACT 
%left LBRA RBRA // Makes sure an array cannot contain + or - for instance in x+A[i]
// Fra diskret: () binder stærkere en ¬ binder stærkere end ∧, ∨ binder stærkere end →, ↔ .
%left IMPLICATION BIIMPLICATION
%left AND OR
%left NOT
%left LPAR RPAR

// We declare the initial non-terminal symbol
%start cExpression

// We specify the return type of each of then non-terminal symbols
%type <a> aExpression
%type <Predicate> bExpression
%type <C> cExpression
%type <GC> gcExpression
%type <D> dExpression

// Grammar productions
%%

// Note that we need to insert an End-Of-File (EOF)
// The code annotation { $1 } specifies that parsing with this production
// returns whatever parsing the expression returns: $1 is the result of parsing
// the first component of the production (i.e. expression)

// The productions for expressions are like in the grammar we saw in class
// written in the yacc format:

dExpression:
  | aExpression { Belief($1) }
  | dExpression COMMA dExpression { BelievesSetSequence($1,$3) }
gcExpression:
  | bExpression CONDITION bExpression { Condition($1,$3) }
  | gcExpression ELSE gcExpression   { Else($1,$3) }
cExpression:
  | VAR EQUAL LCUR dExpression RCUR {BelievesSet($1,$4)}
  | cExpression COMMA cExpression { InitialValues($1,$3) }
  | aExpression ASSIGN LBRA dExpression RBRA { InitialArray($1,$4) }
  | aExpression ASSIGN aExpression   { Assign($1,$3)}
//  | VAR LBRA aExpression RBRA ASSIGN aExpression               { AssignArray($3,$6)}
  | SKIP                             { Skip }
  | cExpression SEQUENCE cExpression { Sequence($1,$3) }
  | IF gcExpression FI               { IfFi($2) }
  | DO gcExpression OD               { DoOd($2) }
aExpression:
  | NUM                               { Num($1) }
  | VAR                               { True($1) } 
  | NOT aExpression                   {Not($2)}
  | aExpression AND aExpression       { And($1,$3) }
  | aExpression OR aExpression        { Or($1,$3) }
  | aExpression ADDITION aExpression  { Addition($1,$3) }
  | aExpression SUBTRACT aExpression  { Subtract($1,$3) }
  | aExpression MULTIPLY aExpression  { Multiply($1,$3) }
  | aExpression DIVIDE aExpression    { Divide($1,$3) }
  | aExpression POWER aExpression     { Power($1,$3) }
  | LPAR aExpression RPAR             { $2 }
  | aExpression LBRA aExpression RBRA { Array($1,$3) } // We may need to replace VAR with ARRAY and add Regex for ARRAY
  | aExpression IMPLICATION aExpression {Implication($1,$3)}
  | aExpression BIIMPLICATION aExpression {BiImplication($1,$3)}
bExpression:
  | FALSE                             { False }
  | aExpression EQUAL aExpression     { Equal($1,$3) }
  | aExpression NEGEQUAL aExpression  { NotEqual($1,$3) }
  | aExpression GT aExpression        { GreaterThen($1,$3) }
  | aExpression GTE aExpression       { GreaterEqual($1,$3) }
  | aExpression LT aExpression        { LessThen($1,$3) }
  | aExpression LTE aExpression       { LessEqual($1,$3) }
  | LPAR bExpression RPAR             { $2 }
// Again, the code annotation specifies the result of parsing
// For example { TimesExpr($1,$3) } specifies that parsing with the production
// returns the value TimesExpr($1,$3), where $i is the result of parsing
// component i in the production (in this case the lhs and rhs operands)

%%
